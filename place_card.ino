/*
 * ==========================================================
 * U8g2 라이브러리 (페이지 버퍼) 적용
 * + Adafruit GFX 호환 '세로' 비트맵 (drawXBMP) 사용
 * ==========================================================
 */

#include <SPI.h>       // RFID용
#include <MFRC522.h>   // RFID용
#include <Servo.h>     // 서보모터용
#include <Wire.h>      // I2C 통신용
#include <LiquidCrystal_I2C.h> // 1. LCD용
#include <U8g2lib.h>   // <--- 2. U8g2 라이브러리

// ===== 핀 설정 =====
const int SERVO_PIN = 9;
const int RED_LED   = 2;
const int GREEN_LED = 3;

// RC522 핀 설정
const int SS_PIN  = 10;
const int RST_PIN = 8;

// TTP229 (8KEY, 2-wire) 핀 설정
const int TTP_CLK_PIN = 7;
const int TTP_DAT_PIN = 6;

// ===== 객체 생성 =====
MFRC522 mfrc522(SS_PIN, RST_PIN);
Servo servo;
LiquidCrystal_I2C lcd(0x27, 16, 2); // 1. LCD 객체

// 2. OLED 객체 (U8g2, RAM 절약 모드)
U8G2_SSD1306_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// ===== 2. 맨 처음에 주셨던 원본 'Adafruit' 배열입니다! =====
// (XBM 변환 배열이 아닌, 맨 처음 주셨던 그 배열)
const unsigned char capstone_bits [] PROGMEM = {
  // '캡스톤, 128x64px (Adafruit GFX 형식)
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x6f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x6b, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x6a, 
	0x80, 0x65, 0xec, 0xb6, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7e, 
	0x40, 0x90, 0x00, 0x26, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x64, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x7f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f, 
	0xc0, 0xc7, 0xf1, 0xf1, 0xfc, 0x3e, 0xb3, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0xc4, 0x33, 0x9b, 0x38, 0x77, 0xb7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0x60, 0x33, 0x3b, 0x30, 0x63, 0xb7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
	0xc0, 0x60, 0xf3, 0xf3, 0x30, 0x63, 0xbf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 
	0xc0, 0xe0, 0x33, 0x80, 0x31, 0x63, 0xbb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 
	0xc0, 0x77, 0x37, 0xf8, 0x31, 0x77, 0xbb, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 
	0x80, 0x37, 0x36, 0xf0, 0x30, 0x3e, 0xb3, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x0f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
	0xc0, 0xe7, 0xf3, 0x99, 0xef, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 
	0xc0, 0xee, 0xbb, 0xdd, 0xef, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 
	0xc0, 0x6c, 0x38, 0xdc, 0xe0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 
	0xc0, 0xec, 0xf3, 0xdd, 0xee, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 
	0xc0, 0x6c, 0x80, 0xd9, 0x6c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 
	0xc0, 0xee, 0xb8, 0xdb, 0x6d, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0c, 0x00, 0xf0, 
	0xc0, 0xe7, 0xf3, 0x99, 0x6f, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x07, 0xfe, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x1f, 0xfe, 0x07, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x7f, 0xff, 0x3f, 0xc0, 
	0x80, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x7f, 0xc0, 
	0x40, 0x9c, 0x52, 0x49, 0x4a, 0x0b, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x1f, 0x7c, 0xc0, 
	0xc0, 0x88, 0x53, 0x49, 0x4a, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x80, 0xff, 0x00, 
	0x40, 0x98, 0x52, 0x49, 0x4a, 0x0d, 0x08, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x0f, 0xff, 0x01, 
	0xc0, 0x85, 0x40, 0x41, 0x32, 0x09, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x1e, 0xff, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0xfe, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x8e, 0xfb, 0x03, 
	0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfd, 0xcf, 0xff, 0xff, 0xbf, 0xfb, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0xf8, 0xff, 0x8f, 0xff, 0xff, 0x7f, 0xf8, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0xff, 0xff, 0xfd, 0xfd, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x00, 0x7e, 0xf0, 0xff, 0x0f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xe0, 0xff, 0x0f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xbf, 0x03, 0x00, 0x00, 0x80, 0xe7, 0x0f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xff, 0xff, 0x00, 0x20, 0x00, 0x00, 0xff, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x7d, 0x3f, 0x00, 0x60, 0x00, 0x00, 0xfc, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x03, 0x00, 0xf8, 0x67, 0x00, 0xf8, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x5c, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0xf0, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xf3, 0x00, 0x00, 0x00, 0x0e, 0x3f, 0x00, 0xe0, 0x0f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xf9, 0x00, 0x00, 0x00, 0x27, 0x38, 0x00, 0x80, 0xec, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x01, 0x00, 0xe0, 0x27, 0x72, 0x00, 0x00, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x00, 0x00, 0xc0, 0x0f, 0xf0, 0x02, 0x00, 0xf6, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x80, 0x7f, 0xf8, 0x02, 0x00, 0xdf, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x80, 0xff, 0xff, 0x02, 0x80, 0xbf, 
	0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x03, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x00, 0x00, 0xfe, 
	0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x01, 0x00, 0xfe, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xf0, 0x21, 0xf9, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

// ===== 동작 파라미터 =====
const unsigned long OPEN_MS          = 7000;
const unsigned long INPUT_TIMEOUT_MS = 25000;
const int READ_DELAY_US = 30;

// 허가된 RFID UID
byte ALLOWED[][4] = { {0x79, 0xA9, 0xEC, 0x20} };
const int ALLOWED_COUNT = sizeof(ALLOWED) / sizeof(ALLOWED[0]);

// PIN 설정
const char* CORRECT_PIN = "1113";
const int PIN_LENGTH = 4;

// ===== 상태 변수 =====
bool doorOpen = false;
unsigned long openedAt = 0;
String pinBuffer = "";
unsigned long lastInputAt = 0;

// === TTP229 디바운스용 ===
const int DEBOUNCE_MS = 20;
static int  lastKey = -1;
static bool waitingRelease = false;


// (TTP229, RFID, LCD, 상태 제어 함수들은 이전과 동일)
// ... (이하 모든 유틸, TTP229, LCD, PIN, 상태제어 함수들) ...

// ===== 유틸리티 함수 (RFID) =====
bool uidEquals(byte *a, byte *b) {
  for (byte i = 0; i < 4; i++) if (a[i] != b[i]) return false;
  return true;
}
bool isAllowed(byte *uid) {
  for (int i = 0; i < ALLOWED_COUNT; i++) if (uidEquals(uid, ALLOWED[i])) return true;
  return false;
}

// ===== TTP229 읽기 함수 =====
uint16_t readRaw16() {
  uint16_t raw = 0;
  digitalWrite(TTP_CLK_PIN, LOW);
  delayMicroseconds(READ_DELAY_US);
  for (int i = 0; i < 16; i++) {
    digitalWrite(TTP_CLK_PIN, HIGH);
    delayMicroseconds(READ_DELAY_US);
    int bit = digitalRead(TTP_DAT_PIN) & 1;
    raw |= (bit << i);
    digitalWrite(TTP_CLK_PIN, LOW);
    delayMicroseconds(READ_DELAY_US);
  }
  return raw;
}

int readKeyIndex8_once() {
  uint16_t raw = readRaw16();
  uint16_t pressed = (~raw) & 0x00FF;
  if (!pressed) return -1;
  if (pressed & (pressed - 1)) return -1;
  int idx = 0;
  while (((pressed >> idx) & 1) == 0) idx++;
  return idx + 1;
}

int fixOffset(int k_raw){
  if (k_raw == -1) return -1;
  int k = k_raw - 1;
  if (k < 1) k = 8;
  if (k > 8) k = 8;
  return k;
}

int readKeyIndex8_singlePress(){
  int a = readKeyIndex8_once();
  delay(DEBOUNCE_MS);
  int b = readKeyIndex8_once();
  int k_raw = (a == b) ? a : -1;
  int k = fixOffset(k_raw);

  if (waitingRelease){
    if (k == -1){ waitingRelease = false; }
    return -1;
  }
  if (k == -1) return -1;
  lastKey = k;
  waitingRelease = true;
  return k;
}

// ===== LCD 표시 함수 =====
void lcdShowTypedPIN() {
  lcd.setCursor(0, 1);
  for (int i = 0; i < 16; i++) lcd.print(' ');
  lcd.setCursor(0, 1);
  for (int i = 0; i < pinBuffer.length(); i++) lcd.print(pinBuffer[i]);
}

void lcdShowWelcome() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Welcome!");
  lcd.setCursor(0, 1); lcd.print("ROOT@ESCAPE~#1");
  openedAt = millis();
}

void lcdShowWrongPIN() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Wrong PIN");
  lcd.setCursor(0, 1); lcd.print("Try again");
  for (int i=0;i<3;i++){ digitalWrite(RED_LED, LOW); delay(120); digitalWrite(RED_LED, HIGH); delay(120); }
  delay(500);
  pinBuffer = "";
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Enter Password");
  lastInputAt = millis();
}

// ===== PIN 검증 함수 =====
void checkPINIfReady(){
  if (pinBuffer.length() < PIN_LENGTH) return;

  if (pinBuffer == CORRECT_PIN) {
    lcdShowWelcome();
  } else {
    lcdShowWrongPIN();
  }
}

// ===== 상태 제어 함수 =====
void setLocked() {
  servo.write(180);
  digitalWrite(RED_LED, HIGH);
  digitalWrite(GREEN_LED, LOW);
  doorOpen = false;
  pinBuffer = "";
  Serial.println("State: Locked");
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Place your card");
}

void setOpened() {
  servo.write(90);
  digitalWrite(RED_LED, LOW);
  digitalWrite(GREEN_LED, HIGH);
  doorOpen = true;
  openedAt = millis();
  pinBuffer = "";
  lastInputAt = millis();
  Serial.println("State: Opened (Waiting for PIN)");
  
  lcd.clear();
  lcd.setCursor(0, 0); 
  lcd.print("Enter Password");
}

void denyBlink() {
  Serial.println("State: Denied (Wrong Card)");
  
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Access Denied");
  lcd.setCursor(0, 1); lcd.print("Unknown Card");

  delay(1000);
  for (int i = 0; i < 3; i++) {
    digitalWrite(RED_LED, LOW); delay(150);
    digitalWrite(RED_LED, HIGH); delay(150);
  }
  delay(1000);
  setLocked();
}


// ===== 3. OLED 그리기 함수 (U8g2 페이지 버퍼 방식) =====
void drawOLED() {

  u8g2.firstPage();
  do {
    // *** 중요: u8g2.drawXBMP() 함수 사용 ***
    // (x, y, 너비, 높이, 비트맵배열)
    u8g2.drawXBMP(0, 0, 128, 64, capstone_bits);
  } while ( u8g2.nextPage() );

}

// ===== 셋업 =====
void setup() {
  Serial.begin(115200);
  Serial.println("Booting...");

  // GPIO 핀
  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(TTP_CLK_PIN, OUTPUT);
  pinMode(TTP_DAT_PIN, INPUT_PULLUP);
  
  // 서보 핀
  servo.attach(SERVO_PIN);
  
  // 1. LCD 초기화
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.print("LCD Init OK");
  delay(500);

  // 2. OLED 초기화 (U8g2)
  if(!u8g2.begin()) { 
    Serial.println(F("U8g2/OLED allocation failed"));
    lcd.clear();
    lcd.print("OLED Init FAIL");
  } else {
    Serial.println(F("OLED Init OK. Drawing bitmap..."));
    drawOLED(); // <--- 4. OLED 그리기 함수 호출
    Serial.println(F("OLED Display OK."));
  }
  
  // SPI 및 RFID 초기화
  Serial.println("Initializing SPI...");
  SPI.begin();
  Serial.println("Initializing MFRC522...");
  mfrc522.PCD_Init();
  mfrc522.PCD_DumpVersionToSerial(); // 연결 상태 확인
  
  // 초기 상태: 잠김
  setLocked();
  
  Serial.println("\nSystem Ready. Place your card.");
}

// ===== 메인 루프 =====
void loop() {
  // (루프는 OLED를 건드리지 않으므로 수정 없음)
  
  // 1. 자동 잠금 처리
  if (doorOpen && (millis() - openedAt >= OPEN_MS)) {
    setLocked(); 
  }

  // 2. RFID 카드 스캔 (문 닫힘 상태)
  if (!doorOpen) {
    if (mfrc522.PICC_IsNewCardPresent()) {
      if (mfrc522.PICC_ReadCardSerial()) {
        if (mfrc522.uid.size == 4) {
          if (isAllowed(mfrc522.uid.uidByte)) {
            setOpened();
          } else {
            denyBlink();
          }
        }
        mfrc522.PICC_HaltA();
        mfrc522.PCD_StopCrypto1();
      }
    }
  }

  // 3. PIN 입력 처리 (문 열림 상태)
  if (doorOpen) {
    int k = readKeyIndex8_singlePress();
    
    if (k != -1) {
      if (k >= 1 && k <= 7) { 
        if (pinBuffer.length() < PIN_LENGTH) {
          char ch = '0' + k;
          pinBuffer += ch;
          lastInputAt = millis();
          lcdShowTypedPIN();
          checkPINIfReady();
        }
      }
    }

    if (pinBuffer.length() > 0 && (millis() - lastInputAt >= INPUT_TIMEOUT_MS)) {
      pinBuffer = "";
      lcd.clear();
      lcd.setCursor(0,0); lcd.print("Timeout - Retry");
      delay(800);
      setOpened();
    }
  }

  delay(10);
}